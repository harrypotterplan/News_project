<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>{{ article.title }} - AI News Master</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <style>
        /* 추가적인 스타일: 본문 내용을 더 읽기 편하게 */
        .article-content {
            line-height: 1.8;
            font-size: 1.1em;
            margin-bottom: 2rem;
            white-space: pre-wrap; /* 본문 내용의 줄바꿈을 유지 */
        }
        body {
            padding-bottom: 70px; /* 하단 버튼 및 푸터 공간 확보 */
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1 class="mb-3">{{ article.title }}</h1>
        <p class="text-muted">
            <strong>카테고리:</strong> {{ article.category | default('미분류') }} &nbsp;|&nbsp;
            <strong>발행일:</strong> {{ article.published_at.strftime('%Y-%m-%d %H:%M') if article.published_at else '알 수 없음' }}
        </p>
        
        <p class="lead">{{ article.summary | default('요약 없음') }}</p>
        
        <div class="article-content">
            <p>{{ article.full_content | default('본문 없음') }}</p>
        </div>

        <a href="{{ article.url }}" target="_blank" class="btn btn-secondary mt-3 mb-4">원문 보기</a>
        
        <div class="mt-3 mb-4 d-flex align-items-center">
            <span class="me-3">이 기사가 유용했나요?</span>
            <button onclick="submitFeedback('like')" class="btn btn-success me-2">
                <i class="bi bi-hand-thumbs-up-fill"></i> 좋아요
            </button>
            <button onclick="submitFeedback('dislike')" class="btn btn-danger me-2">
                <i class="bi bi-hand-thumbs-down-fill"></i> 싫어요
            </button>
            <button id="cancelFeedbackBtn" onclick="submitFeedback('cancel')" class="btn btn-outline-warning">
                피드백 취소
            </button>
        </div>
        
        <a href="{{ url_for('home') }}" class="btn btn-primary mt-3">홈으로</a>
    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">

    <script>
        // --- read_time 및 scroll_depth 추적 로직 시작 ---
        let startTime = Date.now(); // 페이지 로드 시간 (밀리초)
        let maxScrollDepth = 0;     // 최대 스크롤 깊이 (0.0 ~ 1.0)

        window.addEventListener('scroll', () => {
            // 현재 스크롤 위치와 문서 높이를 계산하여 스크롤 깊이 업데이트
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const docHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrollDepth = docHeight > 0 ? scrollTop / docHeight : 0; 
            maxScrollDepth = Math.max(maxScrollDepth, scrollDepth);
        });

        // 사용자가 페이지를 떠날 때 (브라우저 탭 닫기, 다른 페이지 이동 등) 로그 데이터 전송
        window.addEventListener('unload', () => {
            const readTime = Math.round((Date.now() - startTime) / 1000); // 페이지 체류 시간 (초)
            
            // 전송할 데이터 객체 생성
            const data = {
                article_id: {{ article.id }},
                action_type: 'read', // 'read' 액션 명시
                read_time: readTime,
                scroll_depth: maxScrollDepth.toFixed(2) // 소수점 두 자리로 고정
            };

            // navigator.sendBeacon을 사용하여 백그라운드에서 비동기적으로 데이터 전송
            // 이 방식은 페이지가 완전히 언로드되기 전에 요청이 취소될 위험을 줄여줌
            // 서버에서는 request.get_data()로 raw JSON 문자열을 받아 json.loads()로 파싱해야 함
            navigator.sendBeacon('/log_action', JSON.stringify(data));
        });
        // --- read_time 및 scroll_depth 추적 로직 끝 ---


        // --- 피드백 제출 로직 시작 ---
        function submitFeedback(feedbackType) {
            fetch('/feedback', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }, // 서버에 JSON 형식으로 데이터 전송임을 알림
                body: JSON.stringify({
                    article_id: {{ article.id }},
                    feedback_type: feedbackType
                })
            })
            .then(response => {
                if (!response.ok) {
                    // HTTP 상태 코드가 200번대가 아닐 경우 에러 처리
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json(); // 응답 본문을 JSON으로 파싱
            })
            .then(data => {
                if (data.status === 'success') {
                    alert(data.message);
                    // 피드백 제출 성공 후 UI 업데이트 (예: 버튼 활성화/비활성화)
                    updateFeedbackButtons(feedbackType); 
                } else {
                    alert('오류: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error submitting feedback:', error);
                alert('피드백 제출 중 오류가 발생했습니다: ' + error.message);
            });
        }

        // --- 선택 사항: 피드백 버튼 상태 업데이트 함수 (고급 UX) ---
        // 사용자가 좋아요/싫어요를 누르면 해당 버튼은 비활성화하고, 다른 피드백 버튼을 활성화하는 등
        // UX를 개선할 수 있는 로직이야. 실제 구현하려면 백엔드에서 해당 사용자의 현재 피드백 상태를 
        // 가져와서 페이지 로드 시 적용하고, 피드백 제출 후에도 상태를 업데이트해야 해.
        function updateFeedbackButtons(currentFeedback) {
            const likeBtn = document.querySelector('.btn-success');
            const dislikeBtn = document.querySelector('.btn-danger');
            const cancelBtn = document.getElementById('cancelFeedbackBtn');

            // 모든 버튼을 기본 상태(활성화)로 설정
            likeBtn.classList.remove('disabled');
            dislikeBtn.classList.remove('disabled');
            cancelBtn.classList.remove('disabled');

            // 현재 피드백 타입에 따라 버튼 상태 변경
            if (currentFeedback === 'like') {
                likeBtn.classList.add('disabled'); // 좋아요 버튼 비활성화
                likeBtn.textContent = '👍 좋아요 (선택됨)'; // 텍스트 변경
            } else if (currentFeedback === 'dislike') {
                dislikeBtn.classList.add('disabled'); // 싫어요 버튼 비활성화
                dislikeBtn.textContent = '👎 싫어요 (선택됨)'; // 텍스트 변경
            } else if (currentFeedback === 'cancel') {
                // 취소 후에는 모든 버튼 활성화하고 원래 텍스트로 되돌림
                likeBtn.textContent = '좋아요';
                dislikeBtn.textContent = '싫어요';
            }
        }

        // 페이지 로드 시 현재 사용자의 피드백 상태를 가져와 버튼 상태 업데이트 (예시)
        window.onload = function() {
            // 이 부분은 실제 백엔드 API (예: /get_user_feedback_status/article_id)가 필요해.
            // 현재 로그인된 사용자가 이 기사에 대해 어떤 피드백을 남겼는지 가져와서
            // updateFeedbackButtons 함수에 전달하면 돼.
            // 예시:
            /*
            fetch(`/get_user_feedback_status/{{ article.id }}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success' && data.feedback_type) {
                        updateFeedbackButtons(data.feedback_type);
                    } else {
                        updateFeedbackButtons(null); // 피드백 없음
                    }
                })
                .catch(error => console.error('Error fetching feedback status:', error));
            */
            // 임시로 초기화 (실제 배포 시 위 fetch 로직으로 대체)
            updateFeedbackButtons(null);
        };
        // --- 피드백 버튼 상태 업데이트 로직 끝 ---
    </script>
    </body>
</html>